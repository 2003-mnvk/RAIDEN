# -*- coding: utf-8 -*-
"""FinalProject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rSDtuBad70dq212jmBEhW5uLHZn0oPFT
"""

!pip install python-magic pandas matplotlib fpdf pefile

import os
import magic
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
from fpdf import FPDF
from IPython.display import display, HTML, clear_output
from google.colab import files, drive
import pefile
import re
from google.colab import output

# Mount Google Drive
drive.mount('/content/drive')

# Global variables
scan_history = pd.DataFrame(columns=['File Name', 'File Type', 'Risk Level', 'Timestamp', 'Indicators Found'])
report_data = []

# =========================
# ANALYSIS FUNCTIONS
# =========================

def calculate_entropy(data):
    if not data:
        return 0.0

    entropy = 0.0
    data_size = len(data)
    freq_dict = {}

    for byte in data:
        freq_dict[byte] = freq_dict.get(byte, 0) + 1

    for freq in freq_dict.values():
        p_x = freq / data_size
        entropy += -p_x * np.log2(p_x)

    return entropy

def analyze_file_headers(file_path, data):
    indicators = []
    try:
        if len(data) > 2:
            if data[:2] == b'MZ' and not file_path.lower().endswith(('.exe', '.dll', '.sys')):
                indicators.append("PE header found in non-executable file")
            elif data[:4] == b'\x7fELF' and not file_path.lower().endswith(('.so', '.bin', '.elf')):
                indicators.append("ELF header found in unexpected file")
            elif data[:4] == b'%PDF' and not file_path.lower().endswith('.pdf'):
                indicators.append("PDF header found in non-PDF file")

        packer_signatures = {
            b'UPX!': 'UPX packer detected',
            b'ASPack': 'ASPack detected',
            b'FSG!': 'FSG packer detected',
            b'PECompact': 'PECompact detected'
        }

        for sig, message in packer_signatures.items():
            if sig in data[:1000]:
                indicators.append(message)

    except Exception as e:
        indicators.append(f"Header analysis error: {str(e)}")
    return indicators

def analyze_strings(data, min_length=4):
    indicators = []
    try:
        strings = re.findall(b'[\x20-\x7E]{' + str(min_length).encode() + b',}', data)
        strings = [s.decode('ascii', errors='ignore') for s in strings]

        ransom_keywords = [
            'ransom', 'encrypt', 'decrypt', 'bitcoin', 'crypt',
            'pay', 'money', 'wallet', 'aes', 'rsa', 'tor',
            'lock', 'unlock', 'key', 'password', 'cipher'
        ]

        suspicious_apis = [
            'CryptEncrypt', 'CryptDecrypt', 'CreateFile', 'WriteFile',
            'DeleteFile', 'MoveFile', 'FindFirstFile', 'FindNextFile',
            'RegSetValue', 'ShellExecute', 'WinExec', 'CreateProcess'
        ]

        for s in strings:
            for kw in ransom_keywords:
                if kw.lower() in s.lower():
                    indicators.append(f"Ransomware keyword found: {kw}")
                    break

            for api in suspicious_apis:
                if api in s:
                    indicators.append(f"Suspicious API call found: {api}")
                    break

        btc_pattern = r'[13][a-km-zA-HJ-NP-Z1-9]{25,34}'
        eth_pattern = r'0x[a-fA-F0-9]{40}'

        for s in strings:
            if re.search(btc_pattern, s):
                indicators.append("Bitcoin address found")
            if re.search(eth_pattern, s):
                indicators.append("Ethereum address found")

    except Exception as e:
        indicators.append(f"String analysis error: {str(e)}")
    return indicators

def analyze_pe_file(file_path):
    indicators = []
    try:
        pe = pefile.PE(file_path)

        for section in pe.sections:
            section_name = section.Name.decode('utf-8', errors='ignore').strip('\x00')

            if section.SizeOfRawData == 0 and section.Misc_VirtualSize > 0:
                indicators.append(f"Packed section found: {section_name}")

            section_data = section.get_data()
            if len(section_data) > 0:
                entropy = calculate_entropy(section_data)
                if entropy > 7.0:
                    indicators.append(f"High entropy section ({entropy:.2f}): {section_name}")

        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll = entry.dll.decode('utf-8', errors='ignore')
                for imp in entry.imports:
                    if imp.name:
                        func = imp.name.decode('utf-8', errors='ignore')
                        if 'Crypt' in func or 'Encrypt' in func or 'Decrypt' in func:
                            indicators.append(f"Crypto function imported: {func} from {dll}")

        if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
            for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                if resource_type.name is not None:
                    name = str(resource_type.name)
                else:
                    name = pefile.RESOURCE_TYPE.get(resource_type.struct.Id, resource_type.struct.Id)

                if name in ['BIN', 'DATA', 'KEY']:
                    indicators.append(f"Suspicious resource type: {name}")

        pe.close()

    except Exception as e:
        indicators.append(f"PE analysis error: {str(e)}")
    return indicators

def analyze_script(data, ext):
    indicators = []
    try:
        content = data.decode('utf-8', errors='ignore').lower()

        if ext in ['.vbs', '.js']:
            script_keywords = [
                'wscript.shell', 'filesystemobject', 'createobject',
                'run', 'exec', 'eval', 'document.write', 'activexobject',
                'writetofile', 'saveas', 'deletefile'
            ]

            for kw in script_keywords:
                if kw in content:
                    indicators.append(f"Suspicious script keyword: {kw}")

        elif ext == '.ps1':
            ps_keywords = [
                'start-process', 'invoke-expression', 'downloadstring',
                'new-object', 'net.webclient', 'invoke-webrequest',
                'export-clixml', 'convertto-securestring', 'aes', 'rsa'
            ]

            for kw in ps_keywords:
                if kw in content:
                    indicators.append(f"Suspicious PowerShell keyword: {kw}")

        elif ext == '.bat':
            bat_keywords = [
                'del /f /q', 'format ', 'cipher ', 'bitsadmin',
                'certutil -urlcache -split -f', 'wget', 'curl'
            ]

            for kw in bat_keywords:
                if kw in content:
                    indicators.append(f"Suspicious batch command: {kw}")

    except Exception as e:
        indicators.append(f"Script analysis error: {str(e)}")
    return indicators

def analyze_document(data):
    indicators = []
    try:
        if b'\x01Ole10Native' in data[:4096]:
            indicators.append("Embedded OLE object found")

        if b'Macros' in data[:4096] or b'VBA' in data[:4096]:
            indicators.append("Macros/VBA content found")

        exploit_patterns = [
            b'\xD0\xCF\x11\xE0',
            b'\x3C\x00\x4F\x00\x62\x00\x6A\x00\x65\x00\x63\x00\x74\x00'
        ]

        for pattern in exploit_patterns:
            if pattern in data[:4096]:
                indicators.append(f"Potential exploit pattern found: {pattern.hex()}")

    except Exception as e:
        indicators.append(f"Document analysis error: {str(e)}")
    return indicators

def analyze_entropy(entropy, data):
    indicators = []
    try:
        if entropy > 7.5:
            indicators.append(f"Very high overall entropy ({entropy:.2f}), likely encrypted/compressed")
        elif entropy > 7.0:
            indicators.append(f"High overall entropy ({entropy:.2f})")

        if len(data) > 1024:
            chunk_size = 256
            chunks = [data[i:i+chunk_size] for i in range(0, min(len(data), 1024), chunk_size)]
            entropies = [calculate_entropy(chunk) for chunk in chunks]

            if max(entropies) - min(entropies) > 2.0:
                indicators.append("Significant entropy variations detected (possible embedded data)")

    except Exception as e:
        indicators.append(f"Entropy analysis error: {str(e)}")
    return indicators

def analyze_file(file_path):
    try:
        file_info = {}
        file_info['File Name'] = os.path.basename(file_path)
        file_info['File Type'] = magic.from_file(file_path)
        file_info['File Size'] = os.path.getsize(file_path)

        with open(file_path, 'rb') as f:
            bytes_data = f.read()
            file_info['Entropy'] = calculate_entropy(bytes_data)

        _, file_ext = os.path.splitext(file_path)
        file_info['File Extension'] = file_ext.lower()

        indicators = []
        indicators.extend(analyze_file_headers(file_path, bytes_data))
        indicators.extend(analyze_strings(bytes_data))

        if file_ext.lower() in ['.exe', '.dll', '.sys']:
            indicators.extend(analyze_pe_file(file_path))

        if file_ext.lower() in ['.js', '.vbs', '.ps1', '.bat']:
            indicators.extend(analyze_script(bytes_data, file_ext.lower()))

        if file_ext.lower() in ['.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx']:
            indicators.extend(analyze_document(bytes_data))

        indicators.extend(analyze_entropy(file_info['Entropy'], bytes_data))

        file_info['Indicators Found'] = indicators

        risk_level, reason = assess_risk(file_info)
        file_info['Risk Level'] = risk_level
        file_info['Reason'] = reason
        file_info['Timestamp'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        return file_info

    except Exception as e:
        return {'error': str(e)}

def assess_risk(file_info):
    risk_score = 0
    reasons = []
    indicators = file_info.get('Indicators Found', [])

    risk_score += len(indicators) * 10

    suspicious_extensions = ['.exe', '.dll', '.vbs', '.js', '.bat', '.ps1', '.scr', '.lnk']
    encrypted_extensions = ['.encrypted', '.locked', '.crypt', '.ransom']

    if file_info['File Extension'] in suspicious_extensions:
        risk_score += 30
        reasons.append(f"Suspicious file extension: {file_info['File Extension']}")

    if file_info['File Extension'] in encrypted_extensions:
        risk_score += 70
        reasons.append(f"Encrypted file extension: {file_info['File Extension']}")

    if file_info['Entropy'] > 7.5:
        risk_score += 60
        reasons.append(f"Very high entropy ({file_info['Entropy']:.2f}), possibly encrypted/compressed")
    elif file_info['Entropy'] > 7.0:
        risk_score += 40
        reasons.append(f"High entropy ({file_info['Entropy']:.2f})")
    elif file_info['Entropy'] > 6.0:
        risk_score += 20
        reasons.append(f"Moderate entropy ({file_info['Entropy']:.2f})")

    if file_info['File Size'] < 1024:
        risk_score += 20
        reasons.append(f"Very small file size ({file_info['File Size']} bytes)")
    elif file_info['File Size'] > 100 * 1024 * 1024:
        risk_score += 20
        reasons.append(f"Very large file size ({file_info['File Size']/1024/1024:.2f} MB)")

    reasons.extend(indicators)

    if risk_score >= 100 or any('ransom' in r.lower() for r in reasons):
        return 'Critical', ', '.join(reasons)
    elif risk_score >= 70:
        return 'High', ', '.join(reasons)
    elif risk_score >= 40:
        return 'Medium', ', '.join(reasons)
    else:
        return 'Low', 'No significant ransomware indicators detected'

# =========================
# REPORTING FUNCTIONS
# =========================

def generate_pdf_report(file_info):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    pdf.cell(200, 10, txt="Advanced Ransomware Detection Report", ln=1, align='C')
    pdf.ln(10)

    pdf.set_font("Arial", 'B', 12)
    pdf.cell(200, 10, txt="File Information", ln=1)
    pdf.set_font("Arial", size=10)

    pdf.cell(200, 10, txt=f"File Name: {file_info['File Name']}", ln=1)
    pdf.cell(200, 10, txt=f"File Type: {file_info['File Type']}", ln=1)
    pdf.cell(200, 10, txt=f"File Size: {file_info['File Size']} bytes", ln=1)
    pdf.cell(200, 10, txt=f"File Extension: {file_info['File Extension']}", ln=1)
    pdf.cell(200, 10, txt=f"Entropy: {file_info['Entropy']:.2f}", ln=1)
    pdf.ln(5)

    pdf.set_font("Arial", 'B', 12)
    pdf.cell(200, 10, txt="Risk Assessment", ln=1)
    pdf.set_font("Arial", size=10)

    risk_color = {
        'Critical': (255, 0, 0),
        'High': (255, 69, 0),
        'Medium': (255, 165, 0),
        'Low': (0, 128, 0)
    }.get(file_info['Risk Level'], (0, 0, 0))

    pdf.set_text_color(*risk_color)
    pdf.cell(200, 10, txt=f"Risk Level: {file_info['Risk Level']}", ln=1)
    pdf.set_text_color(0, 0, 0)
    pdf.multi_cell(0, 10, txt=f"Reason: {file_info['Reason']}")
    pdf.ln(5)

    if file_info.get('Indicators Found'):
        pdf.set_font("Arial", 'B', 12)
        pdf.cell(200, 10, txt="Detailed Indicators Found", ln=1)
        pdf.set_font("Arial", size=10)

        for indicator in file_info['Indicators Found']:
            pdf.multi_cell(0, 10, txt=f"- {indicator}")
        pdf.ln(5)

    pdf.set_font("Arial", 'B', 12)
    pdf.cell(200, 10, txt="Technical Analysis", ln=1)
    pdf.set_font("Arial", size=10)

    analysis_text = """This report provides an analysis of potential ransomware indicators in the scanned file.
The detection includes:
- File header analysis to detect anomalies
- String analysis for suspicious keywords
- PE file structure analysis for executables
- Script content analysis for scripts
- Document structure analysis for office files
- Entropy analysis to detect encryption/compression

Note: This is an automated analysis. Some indicators may be false positives.
Critical or High risk files should be investigated further by security professionals.
"""
    pdf.multi_cell(0, 10, txt=analysis_text)
    pdf.ln(5)

    pdf.cell(200, 10, txt=f"Scan Time: {file_info['Timestamp']}", ln=1)

    report_filename = f"detailed_ransomware_report_{file_info['File Name']}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
    pdf.output(report_filename)
    return report_filename

def plot_risk_distribution():
    if scan_history.empty:
        return None

    risk_counts = scan_history['Risk Level'].value_counts()

    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.pie(risk_counts, labels=risk_counts.index, autopct='%1.1f%%',
            colors=['green', 'orange', 'red', 'darkred'], startangle=90)
    plt.title('Risk Level Distribution (Pie Chart)')

    plt.subplot(1, 2, 2)
    risk_counts.plot(kind='bar', color=['green', 'orange', 'red', 'darkred'])
    plt.title('Risk Level Distribution (Bar Chart)')
    plt.ylabel('Number of Files')
    plt.xticks(rotation=0)

    plt.tight_layout()
    plt.show()

    chart_path = 'risk_distribution.png'
    plt.savefig(chart_path)
    plt.close()
    return chart_path

# =========================
# UI FUNCTIONS
# =========================

def display_results(file_info):
    risk_class = f"risk-{file_info['Risk Level'].lower()}"

    indicators_html = ""
    if file_info.get('Indicators Found'):
        indicators_html = "<h4>Detailed Indicators:</h4><ul>"
        for indicator in file_info['Indicators Found']:
            indicators_html += f"<li>{indicator}</li>"
        indicators_html += "</ul>"

    result_html = f"""
        <p><strong>File Name:</strong> {file_info['File Name']}</p>
        <p><strong>File Type:</strong> {file_info['File Type']}</p>
        <p><strong>File Size:</strong> {file_info['File Size']} bytes</p>
        <p><strong>Risk Level:</strong> <span class="{risk_class}">{file_info['Risk Level']}</span></p>
        <p><strong>Reason:</strong> {file_info['Reason']}</p>
        {indicators_html}
        <p><strong>Timestamp:</strong> {file_info['Timestamp']}</p>
    """

    display(HTML(f"""
        <script>
            document.getElementById('result-content').innerHTML = `{result_html}`;
            document.getElementById('results').style.display = 'block';
            document.getElementById('download-btn').style.display = 'inline-block';
        </script>
    """))

def update_history_table():
    if not scan_history.empty:
        def color_risk(risk):
            if risk == 'Critical':
                return '<span class="risk-critical">Critical</span>'
            elif risk == 'High':
                return '<span class="risk-high">High</span>'
            elif risk == 'Medium':
                return '<span class="risk-medium">Medium</span>'
            else:
                return '<span class="risk-low">Low</span>'

        colored_history = scan_history.copy()
        colored_history['Risk Level'] = colored_history['Risk Level'].apply(color_risk)

        colored_history['Indicators Found'] = colored_history['Indicators Found'].apply(
            lambda x: f'<span class="risk-high">{x}</span>' if x > 3 else
                     (f'<span class="risk-medium">{x}</span>' if x > 0 else f'<span class="risk-low">{x}</span>')
        )

        history_html = colored_history.to_html(index=False, escape=False)
        display(HTML(f"<div id='history-table'>{history_html}</div>"))

# =========================
# FILE PROCESSING FUNCTIONS
# =========================

def process_file(file_path):
    global scan_history, report_data

    file_info = analyze_file(file_path)

    if 'error' in file_info:
        display(HTML(f"<p style='color:red;'>Error analyzing {os.path.basename(file_path)}: {file_info['error']}</p>"))
        return

    scan_history = pd.concat([
        scan_history,
        pd.DataFrame([{
            'File Name': file_info['File Name'],
            'File Type': file_info['File Type'],
            'Risk Level': file_info['Risk Level'],
            'Timestamp': file_info['Timestamp'],
            'Indicators Found': len(file_info.get('Indicators Found', []))
        }])
    ], ignore_index=True)

    report_filename = generate_pdf_report(file_info)
    report_data.append({
        'filename': report_filename,
        'file_info': file_info
    })

    display_results(file_info)
    update_history_table()
    plot_risk_distribution()

def scan_file():
    uploaded = files.upload()
    if not uploaded:
        return

    for filename in uploaded.keys():
        file_path = os.path.join('/content', filename)
        with open(file_path, 'wb') as f:
            f.write(uploaded[filename])
        process_file(file_path)

def scan_drive_file():
    from IPython.display import display, Javascript
    display(Javascript('''
        const filePath = prompt("Enter the file path in your Google Drive (e.g., MyDrive/Folder/file.exe):");
        google.colab.kernel.invokeFunction('scan_drive_file_callback', [filePath], {});
    '''))

def scan_drive_file_callback(file_path):
    if not file_path:
        display(HTML("<p style='color:red;'>No file path provided</p>"))
        return

    try:
        full_path = f"/content/drive/{file_path}"

        if not os.path.exists(full_path):
            display(HTML(f"<p style='color:red;'>File not found: {full_path}</p>"))
            return

        process_file(full_path)

    except Exception as e:
        display(HTML(f"<p style='color:red;'>Error: {str(e)}</p>"))

def download_report():
    if not report_data:
        display(HTML("<p style='color:red;'>No report available to download</p>"))
        return

    latest_report = report_data[-1]['filename']
    files.download(latest_report)

# =========================
# MAIN UI
# =========================

def display_ui():
    clear_output()

    ui_html = """
    <style>
        table {
            border-collapse: separate;
            border-spacing: 0;
            width: 100%;
            margin: 20px 0;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 255, 255, 0.2);
            font-family: 'Arial', sans-serif;
        }
        th, td {
            padding: 12px 15px;
            text-align: center;
            border: 1px solid #444;
            transition: all 0.3s ease;
        }
        th {
            background-color: #111;
            color: #0ff;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 14px;
            position: sticky;
            top: 0;
        }
        td {
            background-color: #222;
            color: #fff;
        }
        tr:nth-child(even) td {
            background-color: #1a1a1a;
        }
        tr:hover td {
            background-color: #333;
            transform: scale(1.01);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.1);
        }
        .risk-high {
            color: #ff5555;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 85, 85, 0.5);
        }
        .risk-medium {
            color: #ffaa33;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 170, 51, 0.5);
        }
        .risk-low {
            color: #55ff55;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(85, 255, 85, 0.5);
        }
        .risk-critical {
            color: #ff0000;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(255, 0, 0, 0.7);
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            margin: 10px;
            cursor: pointer;
        }
        .button-scan {
            background-color: #4CAF50;
        }
        .button-drive {
            background-color: #4285F4;
        }
        .button-download {
            background-color: #FF9800;
        }
        #results {
            margin: 20px 0;
            padding: 15px;
            border-radius: 5px;
            background-color: #222;
        }
    </style>

    <div class="container">
        <div class="header">
            <h1>AI-Powered Ransomware Detection Tool</h1>
            <p>Upload files to scan for potential ransomware threats</p>
        </div>

        <div>
            <button class="button button-scan" onclick="scanFile()">Scan Local File</button>
            <button class="button button-drive" onclick="scanDrive()">Scan from Google Drive</button>
        </div>

        <div id="results" class="results" style="display:none;">
            <h3>Scan Results</h3>
            <div id="result-content"></div>
            <button id="download-btn" class="button button-download" style="display:none;" onclick="downloadReport()">Download Detailed Report</button>
        </div>

        <div class="history">
            <h3>Scan History</h3>
            <div id="history-table"></div>
        </div>

        <div class="visualization">
            <h3>Risk Distribution</h3>
            <div id="risk-chart"></div>
        </div>
    </div>

    <script>
        function scanFile() {
            google.colab.kernel.invokeFunction('scan_file', [], {});
        }
        function scanDrive() {
            google.colab.kernel.invokeFunction('scan_drive_file', [], {});
        }
        function downloadReport() {
            google.colab.kernel.invokeFunction('download_report', [], {});
        }
    </script>
    """

    display(HTML(ui_html))
    update_history_table()

# =========================
# INITIALIZATION
# =========================

# Register callbacks
output.register_callback('scan_file', scan_file)
output.register_callback('scan_drive_file', scan_drive_file)
output.register_callback('scan_drive_file_callback', scan_drive_file_callback)
output.register_callback('download_report', download_report)

# Initialize the UI
display_ui()